import  pandas as pd
from os import path
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn import preprocessing
import sklearn.feature_selection
import pandas as dd
from sklearn.feature_selection import SelectFromModel, SelectKBest, f_classif
import time
import numpy as np

from sklearn.metrics import confusion_matrix
# fill the rest (numeric)
numeric_features = ['Flow ID', ' Source IP', ' Source Port', ' Destination IP', ' Destination Port', ' Protocol', ' Timestamp', ' Flow Duration', ' Total Fwd Packets', ' Total Backward Packets',' Total Length of Fwd Packets', ' Total Length of Bwd Packets', ' Fwd Packet Length Max', ' Fwd Packet Length Min', ' Fwd Packet Length Mean', ' Fwd Packet Length Std',' Bwd Packet Length Max', ' Bwd Packet Length Min', ' Bwd Packet Length Mean', ' Bwd Packet Length Std',' Flow Bytes', ' Flow Packets', ' Flow IAT Mean', ' Flow IAT Std', ' Flow IAT Max', ' Flow IAT Min',' Fwd IAT Total', ' Fwd IAT Mean', ' Fwd IAT Std', ' Fwd IAT Max', ' Fwd IAT Min',' Bwd IAT Total', ' Bwd IAT Mean', ' Bwd IAT Std', ' Bwd IAT Max', ' Bwd IAT Min',' Fwd PSH Flags', ' Bwd PSH Flags', ' Fwd URG Flags', ' Bwd URG Flags', ' Fwd Header Length', ' Bwd Header Length',' Fwd Packets/s', ' Bwd Packets/s', ' Min Packet Length', ' Max Packet Length', ' Packet Length Mean', ' Packet Length Std', ' Packet Length Variance',' FIN Flag Count', ' SYN Flag Count', ' RST Flag Count', ' PSH Flag Count', ' ACK Flag Count', ' URG Flag Count', ' CWE Flag Count', ' ECE Flag Count', ' Down/Up Ratio', ' Average Packet Size', ' Avg Fwd Segment Size', ' Avg Bwd Segment Size', ' Fwd Header Length',' Fwd Avg Bytes/Bulk', ' Fwd Avg Packets/Bulk', ' Fwd Avg Bulk Rate', ' Bwd Avg Bytes/Bulk', ' Bwd Avg Packets/Bulk',' Bwd Avg Bulk Rate',' Subflow Fwd Packets', ' Subflow Fwd Bytes', ' Subflow Bwd Packets', ' Subflow Bwd Bytes',' Init_Win_bytes_forward', ' Init_Win_bytes_backward', ' act_data_pkt_fwd', ' min_seg_size_forward',' Active Mean', ' Active Std', ' Active Max', ' Active Min',' Idle Mean', ' Idle Std', ' Idle Max', ' Idle Min']
categorical_features = [' CWE Flag Count', 'Flow ID',' Source IP',' Source Port',' Destination IP',' Destination Port',
                        ' Protocol', ' Timestamp']
label_col = ' Label'
cleanup_nums = {"Label":     {"ADWARE_EWIND":1,"ADWARE_DOWGIN":2,"RANSOMWARE_CHARGER": 3,"SMSMALWARE_BEANBOT": 4,

                             "SCAREWARE_ANDROIDSPY": 5,"RANSOMWARE_JISUT":6, "BENIGN": 0, 'SCAREWARE': 7}}
dd_df = dd.read_csv(path.join('data_all','combined', 'combinedAll_csv.csv'))
df = dd_df.sample(frac=0.1)
# .compute()
# df_sample = df[numeric_features]
# df_sample = df_sample.dropna()

print('data read')
# df_sample = df.sample(frac=0.1)
#df_sample.to_csv(path.join('data', 'train_0001.csv'))


df = df.dropna()
print(df.shape)
df = df[~df.applymap(np.isreal).all(1)]
print(df.shape)
X = df.drop([label_col], axis=1)
X = X.drop(categorical_features, axis=1)
print(X.shape)

# Select the ones you want
y = df[[label_col]]

le = preprocessing.LabelEncoder()
le.fit(y)
y = df[le.transform(y)]

print(le.classes_)


sel = SelectFromModel(RandomForestClassifier(n_estimators = 100), max_features=50)
sel.fit(X, y)
sel.get_support()

selected_feat= X.columns[(sel.get_support())]
X_new = X[selected_feat]
print(X_new.shape)

print('training model')
#Create a Gaussian Classifier
clf=RandomForestClassifier(n_estimators=180)

X_new = SelectKBest(f_classif, k=60).fit_transform(X, y)

X_train, X_test, y_train, y_test = train_test_split(X_new, y, test_size=0.2, random_state=42, shuffle=True)
tic = time.perf_counter()
#Train the model using the training sets y_pred=clf.predict(X_test)
clf.fit(X_train,y_train)
toc = time.perf_counter()
print(f"Trained the rf model in {toc - tic:0.4f} seconds")
# prediction on test set
y_pred=clf.predict(X_test)

print(confusion_matrix(y_test, y_pred))
#Import scikit-learn metrics module for accuracy calculation
# Model Accuracy, how often is the classifier correct?
print("Accuracy:",metrics.accuracy_score(y_test, y_pred))
